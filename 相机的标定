cd ~/camera_calibration
cat > circle_grid_calibration.py << 'EOF'
import cv2
import numpy as np
import glob
import os
import json
from datetime import datetime

def find_circle_grid_corners(grid_size=(9,6)):
    """查找圆点网格角点"""
    print("\n开始查找圆点网格角点...")
    objp = np.zeros((grid_size[0] * grid_size[1], 3), np.float32)
    objp[:, :2] = np.mgrid[0:grid_size[0], 0:grid_size[1]].T.reshape(-1, 2)
    
    objpoints = []  # 3D点
    imgpoints = []  # 2D点
    
    images = glob.glob('calibration_images/calib_*.jpg')
    
    if not images:
        print("错误：未找到标定图片，请先采集图片")
        return None, None, None
    
    print(f"找到 {len(images)} 张标定图片")
    
    for i, fname in enumerate(images):
        print(f"处理图片 {i+1}/{len(images)}: {os.path.basename(fname)}")
        
        img = cv2.imread(fname)
        if img is None:
            print(f"  无法读取图片")
            continue
            
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        ret, centers = cv2.findCirclesGrid(
            gray, 
            grid_size, 
            None,
            flags=cv2.CALIB_CB_SYMMETRIC_GRID + cv2.CALIB_CB_CLUSTERING
        )
        
        if ret:
            objpoints.append(objp)
            imgpoints.append(centers)
            img_with_circles = img.copy()
            cv2.drawChessboardCorners(img_with_circles, grid_size, centers, ret)
            combined = np.hstack((img, img_with_circles))
            h, w = combined.shape[:2]
            scale = 800 / h
            new_w, new_h = int(w * scale), int(h * scale)
            combined_resized = cv2.resize(combined, (new_w, new_h))
            
            cv2.putText(combined_resized, "Original", (10, 30), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
            cv2.putText(combined_resized, "With Circles", (new_w + 10, 30), 
                       cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
            
            cv2.imshow('圆点检测结果', combined_resized)
            cv2.waitKey(300)
            
            print(f"  ✓ 找到 {len(centers)} 个圆点")
        else:
            print(f"  ✗ 未找到圆点网格")
            # 尝试其他方法
            ret, centers = cv2.findCirclesGrid(
                gray, 
                grid_size, 
                None,
                flags=cv2.CALIB_CB_ASYMMETRIC_GRID
            )
            if ret:
                print(f"  ✓ 使用非对称网格找到 {len(centers)} 个圆点")
                objpoints.append(objp)
                imgpoints.append(centers)
            else:
                print(f"  ✗ 所有方法都失败")

    cv2.destroyAllWindows()
    
    if not objpoints:
        print("错误：在所有图片中都未找到圆点")
        return None, None, None
    
    print(f"\n成功检测 {len(objpoints)} 张图片的圆点")
    return objpoints, imgpoints, gray.shape[::-1]

（calibrate_camera, save_calibration_results, view_calibration_data等）
def calibrate_camera(objpoints, imgpoints, img_shape):
    """执行相机标定"""
    print("\n开始相机标定...")
  
    ret, camera_matrix, dist_coeffs, rvecs, tvecs = cv2.calibrateCamera(
        objpoints, imgpoints, img_shape, None, None)
    
    mean_error = 0
    for i in range(len(objpoints)):
        imgpoints2, _ = cv2.projectPoints(objpoints[i], rvecs[i], tvecs[i], camera_matrix, dist_coeffs)
        error = cv2.norm(imgpoints[i], imgpoints2, cv2.NORM_L2) / len(imgpoints2)
        mean_error += error
    
    mean_error = mean_error / len(objpoints)
    
    print("=" * 60)
    print("相机标定结果:")
    print("=" * 60)
    print(f"重投影误差: {mean_error:.6f} 像素")
    
    if mean_error < 0.5:
        print("✓ 标定成功! 重投影误差 < 0.5 像素")
    else:
        print("⚠ 重投影误差较大，建议重新采集更多标定图片")
    
    print("\n相机内参矩阵 (Camera Matrix):")
    print(camera_matrix)
    
    print("\n畸变系数 (Distortion Coefficients):")
    print(dist_coeffs.ravel())
    
    return ret, camera_matrix, dist_coeffs, rvecs, tvecs, mean_error

def save_calibration_results(camera_matrix, dist_coeffs, reprojection_error, img_shape):
    """保存标定结果"""
    calibration_data = {
        "timestamp": datetime.now().isoformat(),
        "calibration_type": "circle_grid",
        "camera_matrix": camera_matrix.tolist(),
        "distortion_coefficients": dist_coeffs.tolist(),
        "reprojection_error": reprojection_error,
        "image_resolution": {
            "width": img_shape[0],
            "height": img_shape[1]
        }
    }
    
    # 保存为JSON
    with open('circle_calibration.json', 'w') as f:
        json.dump(calibration_data, f, indent=4)
    
    # 保存为NPZ
    np.savez('circle_calibration.npz',
             camera_matrix=camera_matrix,
             dist_coeffs=dist_coeffs,
             reprojection_error=reprojection_error)
    
    print(f"\n标定结果已保存到:")
    print(f"- circle_calibration.json")
    print(f"- circle_calibration.npz")

def main():
    """主函数"""
    print("=" * 60)
    print("       圆点网格相机标定程序")
    print("=" * 60)
    
    # 设置圆点网格尺寸 - 根据你的标定板调整
    # 常见的有 (4,11), (7,7), (9,6) 等
    grid_size = (9, 6)  # 根据你的圆点标定板调整
    
    print(f"使用圆点网格尺寸: {grid_size}")
    
    objpoints, imgpoints, img_shape = find_circle_grid_corners(grid_size)
    if objpoints is None:
        print("无法进行标定")
        return
        
    if len(objpoints) < 10:
        print(f"警告: 只找到 {len(objpoints)} 张有效图片，建议至少15张")
        confirm = input("是否继续标定? (y/n): ").strip().lower()
        if confirm != 'y':
            return
    
    ret, camera_matrix, dist_coeffs, rvecs, tvecs, reproj_error = calibrate_camera(
        objpoints, imgpoints, img_shape)
    
    save_calibration_results(camera_matrix, dist_coeffs, reproj_error, img_shape)
    
    print("\n标定完成!")
    print(f"重投影误差: {reproj_error:.4f} 像素")

if __name__ == "__main__":
    main()
EOF
