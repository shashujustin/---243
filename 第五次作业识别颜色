//节点1
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import cv2

class CameraNode(Node):
    def __init__(self):
        super().__init__('camera_node')
        self.publisher_ = self.create_publisher(Image, 'camera/image_raw', 10)
        self.bridge = CvBridge()
        self.cap = cv2.VideoCapture(0)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
        self.cap.set(cv2.CAP_PROP_FPS, 30)
        
        if not self.cap.isOpened():
            self.get_logger().error('无法打开摄像头')
            return
            
        self.get_logger().info('摄像头节点已启动，开始发布图像数据')
        self.timer = self.create_timer(0.033, self.timer_callback)
        
    def timer_callback(self):
        ret, frame = self.cap.read()
        if ret:
            try:
                ros_image = self.bridge.cv2_to_imgmsg(frame, 'bgr8')
                ros_image.header.stamp = self.get_clock().now().to_msg()
                ros_image.header.frame_id = 'camera_frame'
                self.publisher_.publish(ros_image)
                # cv2.imshow('Camera View', frame)
                # cv2.waitKey(1)
                
            except Exception as e:
                self.get_logger().error(f'图像转换错误: {str(e)}')
        else:
            self.get_logger().warning('无法从摄像头读取帧')
            
    def __del__(self):
        if hasattr(self, 'cap') and self.cap.isOpened():
            self.cap.release()
        cv2.destroyAllWindows()

def main(args=None):
    rclpy.init(args=args)
    camera_node = CameraNode()
    
    try:
        rclpy.spin(camera_node)
    except KeyboardInterrupt:
        pass
    finally:
        camera_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
//节点2:
          python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import cv2
import numpy as np

class ColorDetectorNode(Node):
    def __init__(self):
        super().__init__('color_detector_node')
        self.subscription = self.create_subscription(
            Image,
            'camera/image_raw',
            self.image_callback,
            10)
        self.bridge = CvBridge()
        self.color_ranges = {
            'red': [
                (np.array([0, 120, 70]), np.array([10, 255, 255])),
                (np.array([170, 120, 70]), np.array([180, 255, 255]))
            ],
            'green': [(np.array([40, 40, 40]), np.array([80, 255, 255]))],
            'blue': [(np.array([100, 150, 0]), np.array([140, 255, 255]))],
            'yellow': [(np.array([20, 100, 100]), np.array([30, 255, 255]))]
        }
        
        self.get_logger().info('颜色识别节点已启动，等待图像数据...')
        
    def image_callback(self, msg):
        try:
            cv_image = self.bridge.imgmsg_to_cv2(msg, 'bgr8')
            
            self.detect_colors(cv_image)
            
        except Exception as e:
            self.get_logger().error(f'图像处理错误: {str(e)}')
    
    def detect_colors(self, image):
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        result_image = image.copy()
        
        detected_colors = []
        for color_name, ranges in self.color_ranges.items():
            mask = np.zeros(hsv.shape[:2], dtype=np.uint8)
            
            for lower, upper in ranges:
                color_mask = cv2.inRange(hsv, lower, upper)
                mask = cv2.bitwise_or(mask, color_mask)
            kernel = np.ones((5, 5), np.uint8)
            mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
            mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            
            for contour in contours:
                area = cv2.contourArea(contour)
                if area > 500:  # 只处理足够大的区域
                    # 计算边界框
                    x, y, w, h = cv2.boundingRect(contour)
                    
                    color_bgr = self.get_color_bgr(color_name)
                    cv2.rectangle(result_image, (x, y), (x+w, y+h), color_bgr, 2)
                    cv2.putText(result_image, f'{color_name} ({int(area)})', 
                               (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color_bgr, 2)
                    
                    center_x = x + w // 2
                    center_y = y + h // 2
                    cv2.circle(result_image, (center_x, center_y), 5, color_bgr, -1)
                    
                    detected_colors.append(color_name)
      
        cv2.imshow('Color Detection Result', result_image)
        cv2.waitKey(1)
        
        if detected_colors:
            color_count = {}
            for color in detected_colors:
                color_count[color] = color_count.get(color, 0) + 1
            color_info = ', '.join([f'{color}({count})' for color, count in color_count.items()])
            self.get_logger().info(f'检测到颜色: {color_info}')
    
    def get_color_bgr(self, color_name):
        """返回颜色的BGR值用于OpenCV绘制"""
        colors = {
            'red': (0, 0, 255),      # BGR中的红色
            'green': (0, 255, 0),    # BGR中的绿色
            'blue': (255, 0, 0),     # BGR中的蓝色
            'yellow': (0, 255, 255)  # BGR中的黄色
        }
        return colors.get(color_name, (255, 255, 255))

def main(args=None):
    rclpy.init(args=args)
    color_detector_node = ColorDetectorNode()
    
    try:
        rclpy.spin(color_detector_node)
    except KeyboardInterrupt:
        pass
    finally:
        color_detector_node.destroy_node()
        rclpy.shutdown()
        cv2.destroyAllWindows()

if __name__ == '__main__':
    main()
